---
title: "Modeling"
format: pdf
editor: visual
---

# Loading Libraries and Data

```{r}
library(qs)
library(tidyverse)
library(mgcv)
library(tvReg)
```

```{r}
modeling_data <- qread("D:/Portfolio Projects/moviestar_analysis/Data/Processed_Data/Modeling/Combined/modeling_data.qs")
names(modeling_data)
```

```{r}
df <- modeling_data$movie_level_df
head(df)
```

# Response Variable Analysis

```{r}
df |> 
  ggplot(aes(x = log_profitability)) +
  geom_density()
```

We have a relatively symmetrical distribution centered around 0. There is a long left tail, and the distribution is peaked.

### Comparison to normal distribution

```{r}
mu <- mean(df$log_profitability)
sigma <- sd(df$log_profitability)
mu;sigma
```

```{r}
ggplot(df, aes(x = log_profitability)) +
  geom_density(
    aes(y = after_stat(density)),
    linewidth = 1,
    color = "black"
  ) +
  stat_function(
    fun = dnorm,
    args = list(mean = mu, sd = sigma),
    linewidth = 1,
    linetype = "dashed",
    color = "red"
  ) + labs(
    title = "Log Profitability: Empirical Density vs Normal",
    subtitle = sprintf("Normal(mean = %.2f, sd = %.2f)", mu, sigma),
    x = "log_profitability",
    y = "Density"
  ) +
  theme_minimal()
```

As previously stated the empirical density is more peaked than the normal density. Less mass in the start of each tail but the length of tails are quite similar.

This plot indicates that the log_profitability response is close to the normal distribution, which will likely be helpful in future steps.

```{r}
qqnorm(df$log_profitability)
qqline(df$log_profitability, col = "red")
```

In the qqplot we can see that the tails are longer than the normal distribution would suggest, particularly for negative outliers.

For now we pocket this information, as it would be helpful especially if we were to create a predictive model and want to create prediction intervals.

# Modeling

## Baseline Model

First I will start with a model that only uses budget and year.

```{r}
baseline_fit <- lm(log_profitability ~ log_budget + year, data = df)
summary(baseline_fit)
```

When adjusted for budget year does not have a statistically significant relationship. However the crux of our research question is based on how our coefficients change with time, so we leave that in for now.

```{r}
plot(baseline_fit)
```

In the residuals vs fitted plot we see that most points are grouped around zero, so that looks okay.

In the QQ plot we see that it managed to adjust well for positive outliers, but there is a longer left tail. There are more movie bombs than the normality assumption would suggest.

In the scale location plot we see that most points are blobbed together, a slight trend appears when averaged but it does not seem visually perceptible.

Lets take a look at residuals vs year.

```{r}
baseline_residuals <- resid(baseline_fit)
plot(x = df$year, y = baseline_residuals)
```

No obvious trend remains.

```{r}
baseline_residuals <- resid(baseline_fit)
plot(x = df$log_budget, y = baseline_residuals)
```

No obvious trend remains (probably worth taking a look at where log budget is close to zero)

```{r}
df |> filter(log_budget < 5)
```

Okay this could use being removed, neither the budget or revenue will be helpful for us.

```{r}
df <- df |> 
  filter(log_budget > 5)
```

```{r}
baseline_fit <- lm(log_profitability ~ log_budget + year, data = df)
summary(baseline_fit)
```

```{r}
baseline_residuals <- resid(baseline_fit)
plot(x = df$log_budget, y = baseline_residuals)
```

There is no obvious trend that remains.

Lets add the IP fields.

## Baseline Model + IP

```{r}
ip_fit <- lm(log_profitability ~ log_budget + year + ip_power_evergreen_prior +
                 ip_power_momentum_prior, data = df)
summary(ip_fit)
```

Both IP evergreen power and IP momentum power are significant.

```{r}
BIC(ip_fit);BIC(baseline_fit)
```

BIC dropped which indicates a better fit.

Both terms are positive, indicating that IP relevance and IP momentum are associated with higher profits and more successful films.

```{r}
plot(ip_fit)
```

Residuals vs fitted are centered around zero.

The QQ plot looks similar, still have issues in the left tail.

The scale location plot looks straight.

No super concerning outliers.

## Adding Actor Variables

```{r}
actor_ip_fit <- lm(log_profitability ~ log_budget + year + 
                  ip_power_evergreen_prior+ ip_power_momentum_prior
                   + actor_momentum_prior_sum + actor_power_prior_sum, data = df)
summary(actor_ip_fit)
```

We can see that actor momentum is associated with movies getting higher profit, this is statistically significant. On the other hand actor power prior, our static term which looks at an actors lifetime contributions up to the time of the movie is not statistically significant.

```{r}
BIC(actor_ip_fit);BIC(ip_fit)
```

BIC improves, which indicates this model is a better fit.

```{r}
plot(actor_ip_fit)
```

Everything looks good.

For simplicity I will remove the power prior sum and stick with the momentum prior sum as that is supported by the data.

```{r}
actor_ip_simple_fit <- lm(log_profitability ~ log_budget + year + 
                  ip_power_evergreen_prior+ ip_power_momentum_prior
                   + actor_momentum_prior_sum, data = df)
summary(actor_ip_simple_fit)
```

```{r}
BIC(actor_ip_fit);BIC(actor_ip_simple_fit)
```

The simple fit helped our BIC drop further, so I'll stick with that for now. It also gives us an interesting result, movie success depends more on what an actor has done recently than their lifetime performance.

## Interacting year with Actor and IP power

For simplicity I will remove the power prior sum and stick with the momentum prior sum as that is supported by the data.

```{r}
interaction_fit <- lm(log_profitability ~ log_budget + year + 
                  ip_power_evergreen_prior+ ip_power_momentum_prior
                   + actor_momentum_prior_sum +
                  ip_power_evergreen_prior:year + ip_power_momentum_prior:year +
                    actor_momentum_prior_sum:year,
                  data = df)
summary(interaction_fit)
```

We can see that none of the interaction terms are significant... lets take a look at the relationship using a non-parametric method.

## Non Parametric Method

Centering year:

```{r}
df <- df |> 
  mutate(
    year_c = year - mean(year)
  )
```

Fitting model:

```{r}
tvc_mod <- gam(
  log_profitability ~
    log_budget +
    factor(year) +              # or smooth(year) if you prefer
    s(year_c, by = ip_power_momentum_prior) +
    s(year_c, by = actor_momentum_prior_sum),
  data = df,
  method = "REML"
)
summary(tvc_mod)
```

```{r}
plot(
  tvc_mod,
  select = 1,
  shade = TRUE,
  main = "Time-Varying Effect of IP Power"
)

plot(
  tvc_mod,
  select = 2,
  shade = TRUE,
  main = "Time-Varying Effect of Actor Power"
)
```

```{r}
library(gratia)
library(dplyr)
library(ggplot2)

# 1) Create a grid of years to evaluate on
yr_grid <- tibble(year_c = seq(min(df$year_c, na.rm=TRUE),
                              max(df$year_c, na.rm=TRUE),
                              length.out = 200))

# 2) Extract smooth estimates on the same grid
# NOTE: use the smooth labels from your model.
# From your plot labels, they look like:
#   s(year_c, by = ip_power_momentum_prior)
#   s(year_c, by = actor_momentum_prior_sum)

ip_s  <- smooth_estimates(tvc_mod,
                          smooth = "s(year_c):ip_power_momentum_prior",
                          newdata = yr_grid)

act_s <- smooth_estimates(tvc_mod,
                          smooth = "s(year_c):actor_momentum_prior_sum",
                          newdata = yr_grid)

# 3) Join + compute dominance Δ(t)
dom <- ip_s %>%
  select(year_c, ip_est = .estimate, ip_se = .se) %>%
  left_join(
    act_s %>% select(year_c, act_est = .estimate, act_se = .se),
    by = "year_c"
  ) %>%
  mutate(
    dom_est = ip_est - act_est,
    dom_se  = sqrt(ip_se^2 + act_se^2),  # conservative (ignores covariance)
    dom_lo  = dom_est - 1.96 * dom_se,
    dom_hi  = dom_est + 1.96 * dom_se
  )

# 4) Plot
ggplot(dom, aes(x = year_c, y = dom_est)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_ribbon(aes(ymin = dom_lo, ymax = dom_hi), alpha = 0.25) +
  geom_line(linewidth = 1) +
  labs(
    title = "Relative Dominance Over Time: IP vs Actor Power",
    subtitle = expression(Delta(t)==beta[IP](t)-beta[Actor](t)),
    x = "year_c",
    y = expression(Delta(t))
  ) +
  theme_minimal()
```

This non-parametric method suggests there may be a quadratic relationship between actor momentum and year. Lets try adding that to our model.

## Quadratic Fit

```{r}
quadratic_fit <- lm(log_profitability ~ log_budget + year + 
                  ip_power_evergreen_prior+ ip_power_momentum_prior
                   + actor_momentum_prior_sum +
                  ip_power_evergreen_prior:year + ip_power_momentum_prior:year +
                    actor_momentum_prior_sum:year + 
                    actor_momentum_prior_sum:I(year^2),
                  data = df)
summary(quadratic_fit)
```

That term is close to significant. Lets start to weed down our model a bit to get something simpler to analyze.

```{r}
quadratic_fit_simplier_1 <- lm(log_profitability ~ log_budget + year + 
                  ip_power_evergreen_prior+ ip_power_momentum_prior
                   + actor_momentum_prior_sum +
                   ip_power_momentum_prior:year +
                    actor_momentum_prior_sum:year + 
                    actor_momentum_prior_sum:I(year^2),
                  data = df)
summary(quadratic_fit_simplier_1)
```

```{r}
BIC(quadratic_fit);BIC(interaction_fit);BIC(quadratic_fit_simplier_1)
```

We can see that the quadratic fit that removed the interaction between year and ip power evergreen improved the fit. Lets see if adding a cubic term to actor momentum will change things.

```{r}
cubic_fit <- lm(log_profitability ~ log_budget + year + 
                  ip_power_evergreen_prior+ ip_power_momentum_prior
                   + actor_momentum_prior_sum +
                   ip_power_momentum_prior:year +
                    actor_momentum_prior_sum:year + 
                    actor_momentum_prior_sum:I(year^2) +
                  actor_momentum_prior_sum:I(year^3),
                  data = df)
summary(cubic_fit)
```

What does effect look like in this model:

```{r}
cubic_coefficents <- coef(cubic_fit)
year <- 1970:2024
effect <- cubic_coefficents[6] + cubic_coefficents[8]*year + 
  cubic_coefficents[9]*year^2 + cubic_coefficents[10]*year^3
plot(year, effect)
```

What did the quadratic effect look like?

```{r}
quadratic_coefficents <- coef(quadratic_fit)
year <- 1970:2024
effect <- quadratic_coefficents[6] + quadratic_coefficents[9]*year + 
  quadratic_coefficents[10]*year^2
plot(year, effect)
```

## What if we treated each year as a fixed effect

```{r}
quadratic_fixed_fit <- lm(log_profitability ~ log_budget + factor(year) + 
                  ip_power_evergreen_prior+ ip_power_momentum_prior
                   + actor_momentum_prior_sum +
                  ip_power_evergreen_prior:year + ip_power_momentum_prior:year +
                    actor_momentum_prior_sum:year + 
                    actor_momentum_prior_sum:I(year^2),
                  data = df)
summary(quadratic_fixed_fit)
```

```{r}
quadratic_fixed_coefficents <- coef(quadratic_fixed_fit)
year <- 1970:2024
effect <- quadratic_coefficents[6] + quadratic_coefficents[9]*year + 
  quadratic_coefficents[10]*year^2
plot(year, effect)
```

With year as a fixed effect we do get significance for our quadratic term.

## TVreg

Quick look at another non-parametric method, a time varying coefficient model.

```{r}
df_tv <- df |>
  dplyr::select(
    log_profitability,
    ip_power_evergreen_prior,
    actor_momentum_prior_sum,
    budget,
    year
  ) |>
  dplyr::mutate(
    log_budget = log(budget),
    year_c = year - min(year)
  ) |>
  na.omit()
head(df_tv)
```

```{r}
tv_mod <- tvLM(
  log_profitability ~
    log_budget +
    ip_power_evergreen_prior +
    actor_momentum_prior_sum,
  z = df_tv$year_c,
  data = df_tv,
  bw = 0.3
)
```

```{r}
coefs <- tv_mod$coefficients
ylim  <- range(coefs[is.finite(coefs)])

plot(
  tv_mod,
  ylim = c(-5,5),
  main = "Time-Varying Coefficients"
)

```

## Checking on constant nature of actor momentum

```{r}
df |> 
  ggplot(aes(x = year, y = actor_momentum_prior_sum, group = year)) +
  geom_boxplot()
```

What if we center scaled on each year?

```{r}
df <- df |> 
  group_by(year) |> 
  mutate(
    actor_momentum_prior_sum_z = (actor_momentum_prior_sum - mean(actor_momentum_prior_sum))/sd(actor_momentum_prior_sum),
    ip_power_momentum_prior_z = 
      (ip_power_momentum_prior - mean(ip_power_momentum_prior))
    /sd(ip_power_momentum_prior)
  ) |> 
  ungroup()
```

```{r}
df |> 
  ggplot(aes(x = year, y = actor_momentum_prior_sum_z, group = year)) +
  geom_boxplot()
```

This way we can focus on how the effect changes because we are center and scaling our variable on each year.

```{r}
tv_mod <- tvLM(
  log_profitability ~
    log_budget +
    ip_power_momentum_prior +
    actor_momentum_prior_sum_z,
  z = df_tv$year_c,
  data = df,
  bw = 0.1
)
```

```{r}
plot(
  tv_mod,
  ylim = c(-1,1),
  main = "Time-Varying Coefficients"
)
```

Lets refit our quadratic fit:

```{r}
quadratic_scaled_fit <- lm(log_profitability ~ log_budget + year + 
                  ip_power_evergreen_prior+ ip_power_momentum_prior_z
                   + actor_momentum_prior_sum_z +
                   ip_power_momentum_prior_z:year +
                    actor_momentum_prior_sum_z:year + 
                    actor_momentum_prior_sum_z:I(year^2),
                  data = df)
summary(quadratic_scaled_fit)
```

```{r}
quadratic_scaled_coefficents <- coef(quadratic_scaled_fit)
year <- 1970:2024
effect <- quadratic_scaled_coefficents[6] + quadratic_scaled_coefficents[8]*year + 
  quadratic_coefficents[9]*year^2
plot(year, effect)
```

Cubic scaled fit:

```{r}
cubic_scaled_fit <- lm(log_profitability ~ log_budget + year + 
                  ip_power_evergreen_prior+ ip_power_momentum_prior_z
                   + actor_momentum_prior_sum_z +
                   ip_power_momentum_prior_z:year +
                    actor_momentum_prior_sum_z:year + 
                    actor_momentum_prior_sum_z:I(year^2) +
                    actor_momentum_prior_sum_z:I(year^3),
                  data = df)
summary(cubic_scaled_fit)
```

```{r}
cubic_scaled_coefficents <- coef(cubic_scaled_fit)
year <- 1970:2024
effect <- cubic_scaled_coefficents[6] + cubic_scaled_coefficents[9]*year + 
  cubic_coefficents[9]*year^2 + cubic_coefficents[9]*year^3
plot(year, effect)
```

## GAM fit 2

```{r}
tvc_scaled_mod <- gam(
  log_profitability ~
    log_budget +
    smooth(year) +              # or smooth(year) if you prefer
    s(year_c, by = ip_power_momentum_prior, k = 10) +
    s(year_c, by = actor_momentum_prior_sum_z, k = 10),
  data = df,
  method = "REML"
)
summary(tvc_scaled_mod)
```

```{r}
plot(
  tvc_scaled_mod,
  select = 1,
  shade = TRUE,
  main = "Time-Varying Effect of IP Power"
)

plot(
  tvc_scaled_mod,
  select = 2,
  shade = TRUE,
  main = "Time-Varying Effect of Actor Power",
  ylim = c(-.1,.4)
)
```

```{r}
yr_grid <- tibble(year_c = seq(min(df$year_c, na.rm=TRUE),
                              max(df$year_c, na.rm=TRUE),
                              length.out = 200))

# 2) Extract smooth estimates on the same grid
# NOTE: use the smooth labels from your model.
# From your plot labels, they look like:
#   s(year_c, by = ip_power_momentum_prior)
#   s(year_c, by = actor_momentum_prior_sum)

ip_s  <- smooth_estimates(tvc_scaled_mod,
                          smooth = "s(year_c):ip_power_momentum_prior",
                          newdata = yr_grid)

act_s <- smooth_estimates(tvc_scaled_mod,
                          smooth = "s(year_c):actor_momentum_prior_sum_z",
                          newdata = yr_grid)

# 3) Join + compute dominance Δ(t)
dom <- ip_s %>%
  select(year_c, ip_est = .estimate, ip_se = .se) %>%
  left_join(
    act_s %>% select(year_c, act_est = .estimate, act_se = .se),
    by = "year_c"
  ) %>%
  mutate(
    dom_est = ip_est - act_est,
    dom_se  = sqrt(ip_se^2 + act_se^2),  # conservative (ignores covariance)
    dom_lo  = dom_est - 1.96 * dom_se,
    dom_hi  = dom_est + 1.96 * dom_se
  )

# 4) Plot
ggplot(dom, aes(x = year_c, y = dom_est)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_ribbon(aes(ymin = dom_lo, ymax = dom_hi), alpha = 0.25) +
  geom_line(linewidth = 1) +
  labs(
    title = "Relative Dominance Over Time: IP vs Actor Power",
    subtitle = expression(Delta(t)==beta[IP](t)-beta[Actor](t)),
    x = "year_c",
    y = expression(Delta(t))
  ) +
  theme_minimal()
```

## What if we excluded 2020-2024

```{r}
df_no_covid <- df |> 
  filter(year < 2020) |> 
  mutate(year_c = year - mean(year))
```

```{r}
tvc_no_covid_mod <- gam(
  log_profitability ~
    log_budget +
    smooth(year) +              # or smooth(year) if you prefer
    s(year_c, by = ip_power_momentum_prior, k = 10) +
    s(year_c, by = actor_momentum_prior_sum_z, k = 10),
  data = df_no_covid,
  method = "REML"
)
summary(tvc_no_covid_mod)
```

```{r}
plot(
  tvc_no_covid_mod,
  select = 1,
  shade = TRUE,
  main = "Time-Varying Effect of IP Power"
)

plot(
  tvc_no_covid_mod,
  select = 2,
  shade = TRUE,
  main = "Time-Varying Effect of Actor Power"
)
```
